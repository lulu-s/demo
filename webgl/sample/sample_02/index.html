<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEMO 02</title>
    <link rel="stylesheet" href="../canvas.css">
    <script src="../../../js/gl-matrix.js"></script>
</head>

<body>
    <script>
        function main() {
            var canvas = document.createElement('canvas');
            document.body.appendChild(canvas)
            var gl = canvas.getContext('webgl');

            if (!gl) {
                alert('æ— æ³•åˆå§‹åŒ–WebGLï¼Œä½ çš„æµè§ˆå™¨ã€æ“ä½œç³»ç»Ÿæˆ–ç¡¬ä»¶ç­‰å¯èƒ½ä¸æ”¯æŒWebGLã€‚')
                return;
            }

            // é¡¶ç‚¹ç€è‰²å™¨ç¡®å®šé¡¶ç‚¹ï¼Œç”± gl_position è¿”å›è®¡ç®—åçš„ç‚¹ä½
            const vsSource = `
                attribute vec4 aVertexPosition;

                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;

                void main() {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                }
            `;

            // ç‰‡æ®µç€è‰²å™¨ç¡®å®šåƒç´ çš„é¢œè‰²ï¼Œç”± gl_FragColor è¿”å›ç»˜åˆ¶
            const fsSource = `
                void main() {
                    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                }
            `;

            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition')
                },
                uniformLocations: {
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                }
            }

            const buffers = initBuffer(gl);

            drawScene(gl, programInfo, buffers);
        }
      

        // åˆ›å»ºç«‹æ–¹ä½“buffer
        function initBuffer(gl) {
            const positionBuffer = gl.createBuffer(); // åˆ›å»ºbuffer
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // ç»‘å®šä¸Šä¸‹æ–‡ï¼Ÿ

            var vertices = [ // è®°å½•æ­£æ–¹å½¢çš„æ¯ä¸€ä¸ªé¡¶ç‚¹
                1.0, 1.0, 0.0,
                -1.0, 1.0, 0.0,
                1.0, -1.0, 0.0,
                -1.0, -1.0, 0.0
            ]

            gl.bufferData( // åˆ›å»ºé¡¶ç‚¹
                gl.ARRAY_BUFFER,
                new Float32Array(vertices),
                gl.STATIC_DRAW
            )

            return {
                position: positionBuffer
            }

        }

        // åˆå§‹åŒ–ç€è‰²å™¨ç¨‹åº
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            // åˆ›å»ºç€è‰²å™¨ç¨‹åº
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            // åˆ›å»ºå¤±è´¥
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram))
            }

            return shaderProgram;
        }

        // åˆ›å»ºæŒ‡å®šç±»å‹çš„ç€è‰²å™¨ï¼Œä¸Šä¼  source æºç å¹¶ä¸”ç¼–è¯‘ 
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type); // åˆ›å»º type ç±»å‹çš„ shader
            gl.shaderSource(shader, source); // ä¸Šä¼  source
            gl.compileShader(shader); // ç¼–è¯‘ shader
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { // æ£€æµ‹æ˜¯å¦ç¼–è¯‘æˆåŠŸ
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader); // å¤±è´¥åˆ é™¤
                return null;
            }
            return shader;
        }

        function drawScene(gl, programInfo, buffers) {
            // æ¸…é™¤ç”»å¸ƒå‰çš„é…ç½®ï¼Ÿ
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clearDepth(1.0) // æ¸…é™¤ä¸€åˆ‡ï¼Ÿ
            gl.enable(gl.DEPTH_TEST) // å¼€å¯æ·±åº¦æµ‹è¯•
            gl.depthFunc(gl.LEQUAL); // Near things obscure far things

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) // æ¸…é™¤ç”»å¸ƒ


            // åˆ›å»ºæ‘„åƒæœº ğŸ“¹
            const fieldOfView = 45 * Math.PI / 180; // 45deg
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight; // æ¯”ä¾‹
            const zNear = 0.1;
            const zFar = 100.0;
            const projectionMatrix = mat4.create();

            mat4.perspective(
                projectionMatrix,
                fieldOfView,
                aspect,
                zNear,
                zFar
            )

            // è®¾ç½®
            var modelViewMatrix = mat4.create();

            mat4.translate(
                modelViewMatrix, // åŠ è½½ç‰¹å®šä½ç½®ï¼Œ
                modelViewMatrix,
                [-0.0, -0.0, -6.0] // å¹¶æŠŠæ­£æ–¹å½¢æ”¾åœ¨è·ç¦»æ‘„åƒæœº6ä¸ªå•ä½çš„çš„ä½ç½®
            )

            {
                // ç»‘å®šæ­£æ–¹å½¢çš„é¡¶ç‚¹ç¼“å†²åˆ°ä¸Šä¸‹æ–‡ï¼Œ
                const numComponents = 3;  // pull out 3 values per iteration
                const type = gl.FLOAT;    // the data in the buffer is 32bit floats
                const normalize = false;  // don't normalize
                const stride = 0;         // how many bytes to get from one set of values to the next
                // 0 = use type and numComponents above
                const offset = 0;         // how many bytes inside the buffer to start from
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexPosition);
            }

            // ä½¿ç”¨ç¨‹åº
            gl.useProgram(programInfo.program)

            // è®¾ç½® uniform
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.projectionMatrix,
                false,
                projectionMatrix
            )
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.modelViewMatrix,
                false,
                modelViewMatrix
            )

            const offset = 0;
            const vertexCount = 4;
            gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);
        }

        main();
    </script>
</body>

</html>